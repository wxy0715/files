## linux操作命令

### 文件上传

![image-20201208161616969](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201208161616969.png)

```xml
查看端口的服务:lsof -i:5672
firewall-cmd --query-port=3306/tcp  # 查看3306端口是否开启
firewall-cmd --zone=public --add-port=3306/tcp --permanent  # 开启3306端口
firewall-cmd --reload  # 重启防火墙
系统信息 
arch 显示机器的处理器架构
uname -m 显示机器的处理器架构
uname -r 显示正在使用的内核版本 
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) 
hdparm -i /dev/hda 罗列一个磁盘的架构特性 
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 
cat /proc/cpuinfo 显示CPU info的信息 
cat /proc/interrupts 显示中断 
cat /proc/meminfo 校验内存使用 
cat /proc/swaps 显示哪些swap被使用 
cat /proc/version 显示内核的版本 
cat /proc/net/dev 显示网络适配器及统计 
cat /proc/mounts 显示已加载的文件系统 

关闭端口号:iptables -A INPUT -p tcp --drop 端口号-j DROP
iptables -A OUTPUT -p tcp --dport 端口号-j DROP
打开端口号：iptables -I INPUT -ptcp --dport 端口号 -j ACCEPT
以下是linux打开端口命令的使用方法。
nc -lp 23 &(打开23端口，即telnet)
netstat -an | grep 23 (查看是否打开23端口)


文件和目录 
ls -F 查看目录中的文件 
ls -l 显示文件和目录的详细资料 
ls *[0-9]* 显示包含数字的文件名和目录名 
tree 显示文件和目录由根目录开始的树形结构
lstree 显示文件和目录由根目录开始的树形结构

用户和群组 
groupadd group_name 创建一个新用户组 
groupdel group_name 删除一个用户组 
groupmod -n new_group_name old_group_name 重命名一个用户组 
useradd -c "Name Surname " -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 "admin" 用户组的用户 
useradd user1 创建一个新用户 
userdel -r user1 删除一个用户 ( '-r' 排除主目录) 
usermod -c "User FTP" -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 
passwd 修改口令 
passwd user1 修改一个用户的口令 (只允许root执行) 
chage -E 2005-12-31 user1 设置用户口令的失效期限 
pwck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的用户 
grpck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的群组 
newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 

文件的权限 - 使用 "+" 设置权限，使用 "-" 用于取消 
ls -lh 显示权限 
ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 
chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 
chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 
chown user1 file1 改变一个文件的所有人属性 
chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 
chgrp group1 file1 改变文件的群组 
chown user1:group1 file1 改变一个文件的所有人和群组属性 
find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 
chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 
chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 
chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 
chmod g-s /home/public 禁用一个目录的 SGID 位 
chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 
chmod o-t /home/public 禁用一个目录的 STIKY 位 

文件的特殊属性 - 使用 "+" 设置权限，使用 "-" 用于取消 
chattr +a file1 只允许以追加方式读写文件 
chattr +c file1 允许这个文件能被内核自动压缩/解压 
chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 
chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 
chattr +s file1 允许一个文件被安全地删除 
chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 
chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 
lsattr 显示特殊的属性 

打包和压缩文件 
bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件 
bzip2 file1 压缩一个叫做 'file1' 的文件 
gunzip file1.gz 解压一个叫做 'file1.gz'的文件 
gzip file1 压缩一个叫做 'file1'的文件 
gzip -9 file1 最大程度压缩 
rar a file1.rar test_file 创建一个叫做 'file1.rar' 的包 
rar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1' 
rar x file1.rar 解压rar包 
unrar x file1.rar 解压rar包 
tar -cvf archive.tar file1 创建一个非压缩的 tarball 
tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件 
tar -tf archive.tar 显示一个包中的内容 
tar -xvf archive.tar 释放一个包 
tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 
tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 
tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 
tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 
tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 
zip file1.zip file1 创建一个zip格式的压缩包 
zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 
unzip file1.zip 解压一个zip格式压缩包 

备份 
dump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份 
dump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份 

JPS工具
jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况
```



## Docker

- uname -r  查看linux内核

  

- cat /etc/os-release 查看linux的基本信息

  

- 常见命令
  port  	  # 查看映射端口对应的容器内部源端口
  pause	  # 暂停容器
  ps        # 猎户容器列表
  pull      # 从docker镜像源服务器拉取指定镜像或者库镜像
  push      # 推送指定镜像或者库镜像至docker源服务器
  restart   # 重启运行的容器
  rm        # 移除一个或多个容器
  rmi       # 移除一个或多个镜像 （无容器使用该镜像才可删除，否则需要删除相关容器才可继续或 -f 强制删除）
  run       # 创建一个新的容器并运行一个命令
  save      # 保存一个镜像为一个 tar 包【对应 load】
  search    # 在 docker hub 中搜索镜像
  start     # 启动容器
  stop      # 停止容器
  tag       # 给源中镜像打标签
  top       # 查看容器中运行的进程信息
  unpause   # 取消暂停容器
  version   # 查看 docker版本号
  wait      # 截取容器停止时的退出状态值

  whereis 镜像名称 #查看镜像位置 

  
  
- run的原理

  ![image-20201023175008970](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201023175008970.png)



### 安装nginx

- 下载 docker pull niginx
- 启动 docker run -d --name nginxtest  -p 7777:80 nginx
- 检查启动 docker ps 
- 内测 curl localhost:7777

### 安装mysql

### 安装apache

### 安装redis

- 下载 docker pull redis

### 安装tomcat

- 下载 docker run -it tomcat:9.0
- 启动 docker run -d --name tomcattest -p 7778:8080 tomcat
- 进入容器 docker exec -it tomcattest /bin/bash
- 刚进去webapps 里面是空的需要copy内容进去
- cp -r webapps.dist/* webapps

### 容器数据卷

- 挂载数据卷 docker run -it -v /wxy/docker-my:/home centos  /bin/bash
- 查看mount docker inspect 容器id
- docker run -d -p 7779:3306 -v /www/server/mysql/conf:/etc/mysql/conf.d -v /www/server/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root  --name mysql-test mysql:8.0.20
- docker volume inspect 容器id

### DOCKERFILE

![image-20201026162131679](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201026162131679.png)

![image-20201026162518624](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201026162518624.png)

- ​    利用dockerfile 构建tomcat和jdk,vim环境

  ```xml
  FROM centos
  MAINTAINER wxy<2357191256@qq.com>
  
  ENV MYPATH /usr/local
  WORKDIR $MYPATH
  
  COPY readme.txt /usr/local/readme.txt
  
  RUN yum -y install vim
  RUN yum -y install net-tools
  
  ADD jdk-8u271-linux-x64.tar.gz /usr/local/
  ADD apache-tomcat-9.0.39.tar.gz /usr/local/
  
  ENV JAVA_HOME /usr/local/jdk1.8.0_271
  ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
  
  ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.39
  ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.39
  
  ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin
  
  EXPOSE 8080
  
  CMD /usr/local/apache-tomcat-9.0.39/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.39/bin/logs/catalina.out
  
  ```

  ```
构造镜像 docker build -t wxydocker.
  ```
  
  

  ```
启动容器 docker run -d -p 9090:8080 --name wxytomcat -v /home/wxy/build/tomcat/test:/usr/local/apache-tomcat-9.0.39/webapps/test -v /home/wxy/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.39/bin/logs wxydocker
  ```

  
  
  ### 打包springboot
  
  ![image-20201026195132025](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201026195132025.png)

### 安装问题

```xml
docker容器内无法联网问题解决,centos8
firewall-cmd --zone=public --add-masquerade --permanent
firewall-cmd --reload
systemctl restart docker
```

## DOCKER COMPOSE

```java
#安装
sudo curl -L "https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
#授权
sudo chmod +x /usr/local/bin/docker-compose
# 检查是否安装成功
docker-compose --version
```

## Thymeleaf

```xml
#spring.thymeleaf.cache = true ＃启用模板缓存。
#spring.thymeleaf.check-template = true ＃在呈现模板之前检查模板是否存在。
#spring.thymeleaf.check-template-location = true ＃检查模板位置是否存在。
#spring.thymeleaf.content-type = text / html ＃Content-Type值。
#spring.thymeleaf.enabled = true ＃启用MVC Thymeleaf视图分辨率。
#spring.thymeleaf.encoding = UTF-8 ＃模板编码。
#spring.thymeleaf.excluded-view-names = ＃应该从解决方案中排除的视图名称的逗号分隔列表。
#spring.thymeleaf.mode = HTML5 ＃应用于模板的模板模式。另请参见StandardTemplateModeHandlers。
#spring.thymeleaf.prefix = classpath：/ templates / ＃在构建URL时预先查看名称的前缀。
#spring.thymeleaf.suffix = .html ＃构建URL时附加到查看名称的后缀。
#spring.thymeleaf.template-resolver-order = ＃链中模板解析器的顺序。
#spring.thymeleaf.view-names = ＃可以解析的视图名称的逗号分隔列表。/ templates / ＃在构建URL时先查看名称的前缀。
#spring.thymeleaf.suffix = .html ＃构建URL时附加到查看名称的后缀。
#spring.thymeleaf.template-resolver-order = ＃链中模板解析器的顺序。
#spring.thymeleaf.view-names = ＃可以解析的视图名称的逗号分隔列表。/ templates / ＃在构建URL时先查看名称的前缀。
#spring.thymeleaf.suffix = .html ＃构建URL时附加到查看名称的后缀。
#spring.thymeleaf.template-resolver-order = ＃链中模板解析器的顺序。
#spring.thymeleaf.view-names = ＃可以解析的视图名称的逗号分隔列表。
```







## Mysql

- SHOW GLOBAL STATUS LIKE 'Question%'  查看查询数量
- qps---queries per seconds 每秒钟查询数量

### 视图

```java
创建视图
	Create view news as  select from n1 union select from n2 union.........
如何修改视图
　　alter view 视图名 as select 语句
　　alter view 视图名 as  select 视图;
显示视图创建情况
　　show create view 视图名;
查看视图
    Show tables；
    Show table status [ from db_name ] [ like ‘pattern’ ]；
    SELECT * FROM information_schema.views where table_name = 'my_view';
删除视图
	drop view 视图名[,视图名…];
重命名视图
	Rename table 视图名 to 新视图名;
```

> 视图的好处

![](https://img2018.cnblogs.com/blog/1215492/201903/1215492-20190306103335338-1776417010.png)



### 存储过程

```java
简单使用
    DROP  PROCEDURE test4;
    
    DELIMITER $$
    CREATE PROCEDURE test4 () 
    BEGIN
     DECLARE var01 VARCHAR(32) DEFAULT '21';
     SELECT var01;
     SET var01 = 'ug';
     SELECT var01; 
    END$$

    CALL test4()
```

### 如何设计一个关系型数据库

```java
首先现有存储模块,分为存储(文件系统)和存储实例(存储管理,缓存机制,SQL解析,日志管理,权限划分,容灾机制,索引模块,锁模块)
```



## reids

- 性能测试:redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 

### 秒杀场景优化

```java
1.数据库:给秒杀数量加unsigned和秒杀成功的订单(用户id和商品id)加唯一索引
2.加入redis缓存
3.页面缓存
4.加了消息队列
5.隐藏秒杀地址
6.图形验证码
7.接口防刷限流
```

![image-20201213155738211](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201213155738211.png)

## RabbitMQ

```java
官网：
    https://www.rabbitmq.com/install-rpm.html
准备：
	yum install 
	build-essential openssl openssl-devel unixODBC unixODBC-devel 
	make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz

下载：
	wget www.rabbitmq.com/releases/erlang/erlang-23.1.1-1.el7.centos.x86_64.rpm
	wget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm
	wget www.rabbitmq.com/releases/rabbitmq-server/v3.8.9/rabbitmq-server-3.8.9-1.noarch.rpm

启动rabbitmq服务
	service rabbitmq-server start
查看rabbitmq服务状态
	service rabbitmq-server status

管理插件：
        rabbitmq-plugins enable rabbitmq_management
访问地址：
        http://47.101.130.87:15672/   (开端口)

访问受限制-需要加用户(在usr/lib/rabbitmq/lib/rabbitmq-serve/sbin下)
	./rabbitmqctl add_user wxy0715 wxy0715
添加权限
    rabbitmqctl set_user_tags wxy0715 administrator
设置虚拟主机访问权限
	rabbitmqctl set_permissions -p "/" wxy0715 ".*" ".*" ".*" 
复制配置文件到/etc/rabbitmq/rabbitmq-env.conf
    https://github.com/rabbitmq/rabbitmq-server/blob/master/docs/rabbitmq.conf.example
登录即可
```

### 端口

1、5672 客户端连接端口。		

2、15672 web管控台端口。	

3、25672 集群通信端口。



## Nginx

### 信号量说明

| TERM, INT | Quick shutdown  （强制关闭）                                 |
| --------- | ------------------------------------------------------------ |
| QUIT      | Graceful shutdown （优雅关闭，会在请求处理完成之后，自动关闭） |
| KILL      | Halts a stubborn process                                     |
| HUP       | Configuration reload   （优雅的重新加载配置文件，如果修改完配置文件，需要重启的话，可以使用这个信号量，使用该信号量重启并不会关闭进程和中断请求）Start the new worker processes with a new configurationGracefully shutdown the old worker processes |
| USR1      | Reopen the log files  （重写一个日志文件）                   |
| USR2      | Upgrade Executable on the fly  （升级执行文件）              |
| WINCH     | Gracefully shutdown the worker processes （优雅的关闭工作进程） |

### nginx 热部署

```java
1. 进入sbin目录 cp nginx nginx.bak 备份nginx文件,然后用新的文件替换旧的文件
2. ps -ef|grep nginx 查看进程 
3. kill -s SIGUSR2 旧进程id  启动新进程 此时新的master 和新的都存在 ,然后查看logs文件里的nginx.pid.oldbin存着旧程程id
4. kill -s SIGWINCH 旧进程id  杀死旧进程的worker process 但master 还在运行
5. 如果新的配置文件没问题:kill -s SIGQUIT 旧进程id 杀死原来的旧的nginx 保留新的,旧的logs文件也会被删除
```

![image-20201101141438182](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201101141438182.png)



### nginx 热部署回滚

```
使用备份的nginx.bak文件覆盖新的文件
操作和上面热部署一样杀死旧的使用备份的
```

### 查看nginx 信息

```
ps -ef |grep nginx 
/www/serve/nginx/sbin/nginx -v 版本
/www/serve/nginx/sbin/nginx -V 信息
```

![image-20201101145721627](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201101145721627.png)



### 虚拟主机的实现

#### 简单配置文件

```java
#user  nobody;
worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
	keepalive_timeout 65;
	
    server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
    }
}
```



#### 多网卡的配置文件(多ip)

```java
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
	keepalive_timeout 65;
	
    server {
        listen       47.101.130.87;
        server_name  localhost;
        location / {
            root   html/server1;
            index  index.html;
        }
    }
    
   server {
        listen       47.101.130.88;
        server_name  localhost;
        location / {
            root   html/server2;
            index  index.html;
        }
    }
    
     server {
        listen       47.101.130.89;
        server_name  localhost;
        location / {
            root   html/server3;
            index  index.html;
        }
    }
}
```



#### 多端口的配置文件

```java
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
	keepalive_timeout 65;
	
    server {
        listen       8000;
        server_name  localhost;
        location / {
            root   html/server1;
            index  index.html;
        }
    }
    
   server {
        listen       8081;
        server_name  localhost;
        location / {
            root   html/server2;
            index  index.html;
        }
    }
    
     server {
        listen       8082;
        server_name  localhost;
        location / {
            root   html/server3;
            index  index.html;
        }
    }
}
```



#### 多域名的配置文件

```java
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
	keepalive_timeout 65;
	
    server {
        listen       80;
        server_name  www.cjree.cn;
        location / {
            root   html/server1;
            index  index.html;
        }
    }
    
   server {
        listen       80;
        server_name  www.cjree.cn1;
        location / {
            root   html/server2;
            index  index.html;
        }
    }
    
     server {
        listen       80;
        server_name  www.cjree.cn2;
        location / {
            root   html/server3;
            index  index.html;
        }
    }
}
```



### 配置文件详解

```java
1、全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。
2、events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。
3、http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。
4、server块：配置虚拟主机的相关参数，一个http中可以有多个server。
5、location块：配置请求的路由，以及各种页面的处理情况。
```



#### main

```java
user  www www;
worker_processes  auto;
pid /opt/nginx/logs/nginx.pid;
worker_rlimit_nofile 12500;
worker_rlimit_core 50M;
working_directory /opt/nginx/tmp;
worker_cpu_affinity 0001 0010 0100 1000;
worker_priority -10;
worker_shutdown_timeout 5s;
timer_resolution 100ms;
daemon on;
lock_file logs/nginx.log;
```



```java
user  nginx;
    指定nginx用户
pid
    master文件路径
worker_rlimit_nofile 20480;
    worker进程的最大打开文件限制数 如果不设置的话，这个值为操作系统的限制 你可以使用	ulimit -a命令来查看 
worker_rlimit——core 50M;
working_directory /opt/nginx.pid;
    worker子进程异常终止后的core文件,用来记录分析问题
worker_processes number|auto;
    启动进程数 通常跟cpu数相等 如不清楚可以设置为auto自动监测 如果想知道自己的系统是几	  核的 可以用下列命令 cat /proc/cpuinfo 或lscpu
worker_cpu——affinity 
     将cpu和worker子进程进行绑定
worker_priority -10;
	linux默认优先级为120,值越小越优先;调整worker子进程的优先级
worker_shutdown——timeout  5s;
     指定worker子进程优雅退出的超时时间
worker_resolution 100ms
     计时器精度,时间间隔越大,系统调用大   
daemon  off(前台) on(后台)
      nginx运行方式,前台用户调试,后台便于生产
```

#### event

```java
events {
    worker_connections  17500;
    accept_mutex on;
    accept_mutex_delay 100ms;
    multi_accept on;
}
```

![image-20201101164851403](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201101164851403.png)

![image-20201101165227511](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201101165227511.png)

![image-20201101165302991](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201101165302991.png)

![image-20201101165653274](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201101165653274.png)



#### server

```java
server_name匹配规则:
	精确匹配->左侧通配符匹配->右侧通配符匹配->正则表达式匹配(高到低)
root和alias的区别
     root可以拼接url传参,alias末尾必须加/,alias只能位于location块中
```

#### location

```java
优先级
	=  ^~  ~  ~*  /{}
/test和/test/的区别
    /test找不到会把这个test当成文件 而 /test/则不会当成文件处理
```

![image-20201101213503454](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201101213503454.png)

#### stub_status  查看nginx的状态以及监控nginx

```java
active connections – 活跃的连接数量
server accepts handled requests — 总共处理了11989个连接 , 成功创建11989次握手, 总共处理了11991个请求
reading — 读取客户端的连接数.
writing — 响应数据到客户端的数量
waiting — 开启 keep-alive 的情况下,这个值等于 active – (reading+writing), 意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接.
```



#### 示例

```java
#user administrator administrators;  #配置用户或者组，默认为nobody nobody。
#worker_processes 2;  #允许生成的进程数，默认为1
#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址
error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg
events {
    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on
    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off
    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport
    worker_connections  1024;    #最大连接数，默认为512
}
http {
    include       mime.types;   #文件扩展名与文件类型映射表
    default_type  application/octet-stream; #默认文件类型，默认为text/plain
    #access_log off; #取消服务日志    
    log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式
    access_log log/access.log myFormat;  #combined为日志格式的默认值
    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。性能优化-开启高效文件传输模式
    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。
    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。

    upstream mysvr {   
      server 127.0.0.1:7878;
      server 192.168.10.121:3333 backup;  #热备
    }
    error_page 404 https://www.baidu.com; #错误页
    server {
        keepalive_requests 120; #单连接请求上限次数。
        listen       4545;   #监听端口
        server_name  127.0.0.1;   #监听地址       
        location  ~*^.+$ {       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。
           #root path;  #根目录
           #index vv.txt;  #设置默认页
           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表
           deny 127.0.0.1;  #拒绝的ip
           allow 172.18.5.54; #允许的ip           
        } 
    }
}

几个常见配置项：
    1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；
    2.$remote_user ：用来记录客户端用户名称；
    3.$time_local ： 用来记录访问时间与时区；
    4.$request ： 用来记录请求的url与http协议；
    5.$status ： 用来记录请求状态；成功是200；
    6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；
    7.$http_referer ：用来记录从那个页面链接访问过来的；
    8.$http_user_agent ：记录客户端浏览器的相关信息；
```



### HTTP核心模块

```java
connection是连接,即常说的tcp连接,三次握手,状态机
request是请求,例如http请求,无状态的协议
request是必须建立在connection之上
1XX:消息类
2XX:成功类
3XX:重定向
    301:永久冲定向
    302:临时重定向,禁止缓存
    303:临时重定向,禁止缓存,允许改变方法
    307:临时重定向,禁止缓存,不允许改变方法
    308:临时重定向,不允许改变方法
4XX:客户端错误
5XX:服务器错误
```

#### Nginx的请求限制和连接限制

在配置nginx的过程中我们需要考虑受到攻击或恶意请求的情况，比如单用户恶意发起大量请求，这时Nginx的请求限制可以帮助我们对其进行限制。

```java
连接频率限制 : limit_conn_module
请求频率限制 : limit_req_module
HTTP请求建立在一次TCP连接基础上
一次TCP连接至少产生一次HTTP请求
```

##### 连接限制

```java
http {
   ##对单个ip、单个会话同时存在的连接数的限制。这里定义一个存储区conn_zone，conn_zone的容量是1m，该存储区针对于变量$binary_remote_add生效，这里是针对单个IP生效。该模块只是一个定义，配置在http配置段，需要配合limit_conn指令使用才生效， limit_conn one 1表示该location段使用conn_zone定义的 limit_conn_zone ，对单个IP限制同时存在一个连接。
    limit_conn_zone $binary_remote_addr zone=conn_zone:1m;
    server {
            location / {
                    limit_conn conn_zone 1;
            }
}
```

```
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    #keepalive_timeout  65;
    limit_conn_zone $binary_remote_addr zone=limit_addr:10m;
    server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
	    limit_conn_status 503;
	    limit_conn_log_level warn;
	    limit_conn limit_addr 2;
	    limit_rate 50;
        }
    }
}
```



##### 请求限制基本指令

```java
limit_req_zone
语法:limit_req_zone key zone=name:size rate=rate;
只能在http块中使用
此指令用于声明请求限制zone，zone可以保存各种key的状态，name是zone的唯一标识，size代表zone的内存大小，rate指定速率限制。
    
1.key，
若客户的请求匹配了key，则进入zone。可以是文本、变量，通常为Nginx变量。
如$binary_remote_addr(客户的ip)，$uri(不带参数的请求地址)，$request_uri(带参数的请求地址)，$server_name(服务器名称)。支持组合使用，使用空格隔开。
2.zone
使用zone=test，指定此zone的名字为test。
3.size
在zone=name后面紧跟:size，指定此zone的内存大小。如zone=name:10m，代表name的共享内存大小为10m。通常情况下，1m可以保存16000个状态。
4.rate
使用rate=1r/s，限制平均1秒不超过1个请求。使用rate=1r/m，限制平均1分钟不超过1个请求。
5.例子
limit_req_zone $binary_remote_addr zone=one:10m rate=5r/s;
同一ip同一请求地址，进入名为two的zone，限制速率为1请求/秒。
limit_req_zone $binary_remote_addr $uri zone=two:10m rate=1r/s;
同一ip不同请求地址，进入名为one的zone，限制速率为5请求/秒。
```

```java
http {
   #$binary_remote_addr表示的是客户端的地址,zone=req_zone:1m代表的是开辟了一个名为req_zone的1M的空间,1M的空间可以存储多少个$binary_remote_addr这里不解释了 , Nginx官网文档介绍的相当清除 , 速率rate=1r/s代表的是每秒1个 , 所以这里定义的配置代表：对于同一ip的请求，限制平均速率为1个请求/秒。
    limit_req_zone $binary_remote_addr zone=req_zone:1m rate=1r/s;
    server {
            location / {
                    root  /usr/share/nginx/html;
                    index  index.html index.htm;
#请求限制 : 对于符合名为req_zone的limit_req_zone 配置(对于同一ip的请求，限制平均速率为1个请求/秒) , 超过部分进行延迟处理，若超过3个请求/秒，丢弃超过部分。
                    limit_req zone=req_zone burst=3 nodelay;
#请求限制 : 对于符合名为req_zone的limit_req_zone 配置 ,超过部分进行延迟处理，若超过3个请求/秒，所有请求都被过度延迟,直到名为req_zone的limit_req_zone 配置设置的1M存储区被占满,如果存储区耗尽，则删除最近最少使用的状态。即使在此之后无法创建新状态，请求也会因错误而终止。
                    limit_req zone=req_zone burst=3;
#请求限制 : 对于符合名为req_zone的limit_req_zone 配置(对于同一ip的请求，限制平均速率为1个请求/秒) 若超过1个请求/秒，所有请求都被过度延迟,直到名为req_zone的limit_req_zone 配置设置的1M存储区被占满,如果存储区耗尽，则删除最近最少使用的状态。即使在此之后无法创建新状态，请求也会因错误而终止。
                    limit_req zone=req_zone;
}
```

```java
    limit_conn_zone $binary_remote_addr zone=limit_addr:10m;
    limit_req_zone  $binary_remote_addr zone=limit_req:15m rate=12r/m;
    server {
        listen       80;
        server_name  localhost;

        location / {
            root   html;
            index  index.html index.htm;
            error_log logs/limit_req_error.log info;
	    limit_conn_status 503;
	    limit_conn_log_level warn;
	    limit_conn limit_addr 2;
	    limit_rate 50;每秒返回50字节数据
	
	    limit_req_status 504;
	    limit_req_log_level notice;
	    limit_req zone=limit_req;
#	    limit_req zone=limit_req burst=7 nodelay;
        }
    }
```



#### 限制特定网段访问的access模块

```java
location / {
    root   html;
    index  index.html index.htm;
    error_log logs/limit_req_error.log info;

    allow 192.168.184.0/24; 放行
    deny all; 拒绝其他
}
```

#### 限定特定用户的auth_basic模块

> 先安装
>
> yum install apr apr-util
>
> rpm -ivh libpcap-1.5.3-11.el7.x86_64.rpm
> rpm -ivh httpd-tools-2.4.6-90.el7.centos.x86_64.rpm
>
> 在nginx目录下 mkdir auth 
>
> 使用htpasswd -b -c encrypt_pass wxy0715 wxy0715命令创建用户密码
>
> 使用htpasswd -b  encrypt_pass wxy wxy命令增加用户密码

```java
通过--without-hhtp_auth_basic_module禁用
server {
        listen  5560;
        server_name  localhost;
        location / {
            try_files $uri $uri/ @router;
            root /www/server/nginx/html;
            index  index.html index.htm;
        }

        location @router {
            rewrite ^.*$ /index.html last;
        }

        location /bbc/ {
            auth_basic "test user pass";
            auth_basic_user_file /www/server/nginx/auth/encrypt_pass;
            try_files $uri $uri/ @router;//vue寻找路由
            root /www/server/nginx/html;
            index index.html;
 }
```

#### HTTP响应状态码做权限的auth_request模块

> --with-http_auth_request_module

```
server {
     listen 8080;
     charset utf-8;
     location /auth.html {
         return 200 "Failed,give the Page of Auth Server Success\n"; 
     }
}
```



### rewrite

#### return指令

```java
server {
	listen 8000;
	root html;
	location / {
	    #return 200 "return 200 HTTP Code";
	    #return 302 /bbs;
	    return http://192.168.184.240:8000/bbs;
	}
	location /bbs {
	    index bbs.html;
	}
}
```

```java
rewrite regex replacement [flag];
上下文:server,location,if
```

#### flag

| 标记符号  | 说明                                               |
| --------- | -------------------------------------------------- |
| last      | 本条规则匹配完成后继续向下匹配新的location URI规则 |
| break     | 本条规则匹配完成后终止，不在匹配任何规则           |
| redirect  | 返回302临时重定向                                  |
| permanent | 返回301永久重定向                                  |

| \         | 将后面接着的字符标记为一个特殊字符或者一个原义字符或一个向后引用 |
| --------- | ------------------------------------------------------------ |
| ^         | 匹配输入字符串的起始位置                                     |
| $         | 匹配输入字符串的结束位置                                     |
| *         | 匹配前面的字符零次或者多次                                   |
| +         | 匹配前面字符串一次或者多次                                   |
| ?         | 匹配前面字符串的零次或者一次                                 |
| .         | 匹配除“\n”之外的所有单个字符                                 |
| (pattern) | 匹配括号内的pattern                                          |

#### 应用场景：

-  调整用户浏览的URL，看起来规范
- 为了让搜索引擎收录网站内容，让用户体验更好
- 网站更换新域名后
- 根据特殊的变量、目录、客户端信息进行跳转

#### if

```java
server {
	listen 8080;
	server_name localhost;
	root html;
	location /search/ {
	    if ( $remote_addr = "192.168.184.1" ) {
		return 200 "test if OK in URL /search/";
	    } 
	}
	location / {
	    if ( $  = "/images/" ) {
		rewrite (.*) /pics/ break;
	    }
	    return 200 "test if failed\n";
	}
	location /test/ {	    
	}
}
```

![image-20201102141803066](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201102141803066.png)



#### autoindex

```java
Nginx默认是不允许列出整个目录的。
     1、如需此功能，打开nginx.conf文件，在location server 或 http段中加入
               autoindex on;
     2、另外两个参数最好也加上去:
               autoindex_exact_size off;
          默认为on，显示出文件的确切大小，单位是bytes。
          改为off后，显示出文件的大概大小，单位是kB或者MB或者GB
               autoindex_localtime on;
          默认为off，显示的文件时间为GMT时间。
```

```java
location /download/ {
	    root /opt/source;
	   # index b.html;
	    autoindex on;
	    autoindex_exact_size off;
	    autoindex_format html;
	    autoindex_localtime off;
}
```

#### 变量

```java
HTTP框架提供的变量：
	1、TCP连接相关变量
        remote_addr				客户端地址，例如192.168.1.1
        remote_port				客户端端口，例如58473
        binary_remote_addr		客户端地址的整型格式
        connection				已处理连接，是一个递增的序号
        connection_request		当前连接上执行的请求数，对于keepalive连接有意义
        proxy_protocol_addr		如果使用proxy_protocol协议，则返回原始用户的地										址，否则为空
        proxy_protocol_port		如果使用proxy_protocol协议，则返回原始用户的端										口，否则为空
        server_addr				服务器地址，例如192.168.184.240
        server_port				服务器端口,例如80
        server_protocol			服务端协议，例如HTTP/1.1

	2、HTTP请求相关变量
        conten_length	请求包体头部长度
        content_type	请求包体类型
        arg_参数名		URL中某个参数
        args			所有URL参数
        is_args			URL中有参数，则返回?；否则返回空
        query_string	与args完全相同
        uri				请求的URL，不包含参数
        request_uri		请求的URL，包含参数
        scheme			协议名，http或者https
        request_method	请求的方法，GET、HEAD、POST等
        request_length	所有请求内容的大小，包含请求行，头部，请求体
        remote_user		由HTTP Basic Authentication协议传入的用户名
        request_body_file	暂缺
        request_body		暂缺
        request				暂缺
		
    3、Nginx处理请求时相关变量	
        request_time				请求处理到现在所耗费的时间，单位为秒，例如0.03			 							代表30毫秒
        request_completion			请求处理完成，则返回OK，否则为空
        request_id					16进制显示的请求id，随机生成的
        server_name					匹配上请求的server_name值
        https						若开启https，则值为on,否则为空
        request_filename			待访问文件的完整路径
        document_root				由URI和root/alias规则生成的文件夹路径
        realpath_root				将document_root中的软链接换成真实路径
        limit_rate					返回响应时的速度上限值
		
	4、Nginx返回响应时相关变量
        body_bytes_sent				响应体中真实内容的大小	
        body_sent					全部响应体大小
        status						HTTP返回状态码
			
	5、系统变量
         time_local	以本地时间的标准输出
         pid		所属worker进程的id
         hostname	与系统上输出hostname 一致
```

![image-20201102145212518](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201102145212518.png)

```java
	location / {
	    auth_basic  "Test Auth";
	    auth_basic_user_file  auth/encrypt_pass;
	    return 200 "uri:	             $uri
                    request_uri:         $request_uri
                    scheme:              $scheme
                    request_method:      $request_method
                    request_length:      $request_length
                    args:                $args
                    is_args:             $is_args
                    arg_pid:	     $arg_pid
                    query_string:        $query_string
                    remote_user:         $remote_user
                    host:		     $host
                    $request_time
                    $request_id
                    $server_name
                    $request_filename
                    $document_root
                    $realpath_root
                    $request_completion
                    $limit_rate
					";
	}
```



### 反向代理

#### upstream

![image-20201102161326555](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201102161326555.png)

![image-20201102161742996](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201102161742996.png)

![image-20201102161816751](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201102161816751.png)

```java
随机数的html文件
#!/bin/bash
#

DIR=/opt/nginx/html/app/proxy
FILE=proxy.html

while true;do
	echo "Application Server,This time create number: $RANDOM" > $DIR/$FILE
	sleep 1
done
```

```java
upstream back_end {
	server 192.168.184.20:8080 weight=2 max_conns=1000 fail_timeout=10s max_fails=3;
	keepalive 32;
	keepalive_requests 80;
	keepalive_timeout 20s;
} 

server {
	listen 80;
	server_name proxy.kutian.edu;

	location /proxy {
	    proxy_pass http://back_end/proxy;
	}
}

```

##### proxy_pass带不带/的区别

```
不带的话 url 不会改变 
带的话 url会把location匹配的删除
```

![image-20201102164622296](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201102164622296.png)



#### 接受用户请求包体的方式

```java
指令：
    proxy_request_buffering on;
    client_max_body_size 1M
    client_body_buffer_size 16k;
    client_body_in_single_buffer on;
	#指示是否将请求体完整的写入到一个连续的内存中，默认未off；若为on，则Nginx会保证在请求体不大于client_body_buffer_size时，都存放到一块连续的内存中，但超过大小时仍然会整体写入到磁盘的临时文件中
		client_body_temp_path client_body_temp;
		client_body_in_file_only on;
			off		禁用文件写入
			clean	请求体将被写入文件，但在处理完请求后删除
			off		请求体将被写入文件，处理完请求后不删除
```

```java
	location /receive/ {
	    proxy_pass http://test_server;
	    client_max_body_size 250k;
	    #client_body_buffer_size 100k;
	    client_body_temp_path test_body_path;
	    
	    client_body_in_file_only on;
	    #client_body_in_single_buffer on;
	
	    #proxy_request_buffering on;
	    #clent_body_timeout 30;
	}
```

 #### Nginx改变发给上游的用户请求

```java
location / {
    return 200 '以下是请求行变量：
    request_method:    $request_method
    uri:               $uri
    request:           $request
    以下是请求头变量：
    http_test:         $http_test
    content_length:    $content_length
    content_type:      $content_type
    ';
}
```

```java
location /request/ {
    proxy_pass http://192.168.184.20:8888;
    #proxy_method PUT;
    proxy_http_version 1.1;
    #proxy_set_header test "var modify by nginx";
    #proxy_pass_request_headers off;
    #proxy_set_body "OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO";
    #proxy_pass_request_body off;
}
```

#### 参数

```java
include       mime.types;   #文件扩展名与文件类型映射表
default_type  application/octet-stream; #默认文件类型，默认为text/plain
#access_log off; #取消服务日志    
log_format myFormat ' $remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式
access_log log/access.log myFormat;  #combined为日志格式的默认值
sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。
sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。
keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。
proxy_connect_timeout 1;   #nginx服务器与被代理的服务器建立连接的超时时间，默认60秒
proxy_read_timeout 1; #nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。
proxy_send_timeout 1; #nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。
proxy_http_version 1.0 ; #Nginx服务器提供代理服务的http协议版本1.0，1.1，默认设置为1.0版本。
#proxy_method get;    #支持客户端的请求方法。post/get；
proxy_ignore_client_abort on;  #客户端断网时，nginx服务器是否终端对被代理服务器的请求。默认为off。
proxy_ignore_headers "Expires" "Set-Cookie";  #Nginx服务器不处理设置的http相应投中的头域，这里空格隔开可以设置多个。
proxy_intercept_errors on;    #如果被代理服务器返回的状态码为400或者大于400，设置的error_page配置起作用。默认为off。
proxy_headers_hash_max_size 1024; #存放http报文头的哈希表容量上限，默认为512个字符。
proxy_headers_hash_bucket_size 128; #nginx服务器申请存放http报文头的哈希表容量大小。默认为64个字符。
    
proxy_next_upstream timeout;#反向代理upstream中设置的服务器组，出现故障时，被代理服务器返回的状态值。	error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off
error：建立连接或向被代理的服务器发送请求或读取响应信息时服务器发生错误。
timeout：建立连接，想被代理服务器发送请求或读取响应信息时服务器发生超时。
invalid_header:被代理服务器返回的响应头异常。
off:无法将请求分发给被代理的服务器。
http_400，....:被代理服务器返回的状态码为400，500，502，等。
```



### 负载均衡

#### 负载均衡算法

- **源地址哈希法**：根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。---ip_hash
- **轮询法**：将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。
- **随机法**：通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。
- **加权轮询法**：不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。---weight
- **加权随机法**：与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。
- **最小连接数法**：由于后端服务器的配置不尽相同，对于请求的处理有快有慢，最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。----zone = tets;  least:conn;

### 缓存

https://linux.cn/article-5945-1.html

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190807195719359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA0MDYx,size_16,color_FFFFFF,t_70)

![image-20201102201052597](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201102201052597.png)


```java
path：文件缓存路径
manage_sleep CM清理一次后进程的休眠时间;默认200ms
manage_files CM清理一次缓存文件,最大清理文件数;默认100
```





### 提升nginx利用cpu的效率

```java
1.指定worker子进程的个数
2.将worker子进程与每个cpu绑定
3.提高worker子进程的进程优先级 worker_priority
4.延迟处理新连接 listen 80 defered;
```

### TCP建立连接优化

![image-20201102210352357](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201102210352357.png)

### 启用TCP的Fast_open

sysctl -a | grep fast

vim /etc/sysctl.conf 

net.ipv4.tcp_fast_open

### AB压力测试

![image-20201103110344100](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201103110344100.png)





## 计算机网络

![图片描述](https://szimgapi.mukewang.com/5e6fa15f0841966011201587.jpg)

